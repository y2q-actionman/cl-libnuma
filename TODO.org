# -*- mode: org; -*-

* not implemented features

- [X] Enable to set a callback for numa_error() and numa_warn().

- [X] checks libc-semantic return values. 


* enhancement

- [X] Introduce 'bitmask' defclass.
  And more, 'nodemask' or 'cpumask' class?
  Or, List?

- [X] bitmask operations for cl-libnuma:bitmask type?

- [ ] Prints appropriate messages when libnuma headers are not found.

- [X] (numa-move-pages: support nodes-list as a bitvector-type)
  Dropped. I mistaken its argument.

- [X] rewrite smp test with cffi:mem-aref, and boudeaux-threads. 

- [X] supply a library name for overriding syntax definitions.
  (RTLD_NEXT, or a library name, or cffi library name (cffi::get-foreign-library) ..)

- [ ] Tests for basic bindings

- [ ] Tests checking whether numa_error() was called or not.

- [ ] malloc-pointer type?

- [ ] make-numa-bitmask should take a 'T' instead of 'NIL'?

- [ ] rewrite layered calls with foreign-funcall

- [ ] Fix:: numa-node-to-cpus with -1 causes segfault.


* additional features

- [X] (Should I make 'getpid' ready?)
  or, check interoperability with excl.osi, etc.
  -- Dropped. We can use 'pid=0' as a pid of the current process.

- [ ] Import errno?
  numa-move-pages returns an array filled with errno.

- [X] checks libnuma version?
  for numa-num-possible-cpus


* libnuma manpage bugs

- numa_num_possible_cpus()
  This does not exist at the top of man page, and has no explanations!

- numa_free_cpumask(), numa_free_nodemask()
  The manpage says nothing, but this function takes a pointer to
  struct bitmask! (K&R C style!?)

- numa_get_interleave_node()
  source says this is undocumented

- numa_get_run_node_mask()
  manpage says this returns a CPU mask, but source says it's a node mask!

- numa_node_to_cpus()
  A trivial issue: manpage doesn't highlight numa_allocate_cpumask()

- numa_pagesize()
  source says 'not documented', and don't appear at the top of
  manpage, but description is found!

- numa_distance()
  If arguments are out-of-range, this simply returns an undefined
  value (which is read from out of the 'distance_table' of libnuma.)

- numa_set_membind()
  If an error occured, numa_error() is called.
